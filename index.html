<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dyadische Polynomdivision Animation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .bit-container {
            display: flex;
            gap: 0.25rem; /* 4px */
        }
        .bit {
            width: 1.8rem; /* 28.8px */
            height: 1.8rem; /* 28.8px */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 0.375rem; /* 6px */
            background-color: #e0e7ff; /* indigo-100 */
            color: #1e3a8a; /* indigo-900 */
            font-weight: 600;
            transition: background-color 0.3s ease, color 0.3s ease, transform 0.3s ease;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .bit.active {
            background-color: #6366f1; /* indigo-500 */
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .bit.highlight {
            background-color: #fcd34d; /* amber-300 */
            color: #78350f; /* amber-900 */
            transform: scale(1.05);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .bit.result {
            background-color: #a78bfa; /* violet-400 */
            color: white;
        }
        .bit.xor-result {
            background-color: #8b5cf6; /* violet-500 */
            color: white;
            font-weight: 700;
        }
        .operation-line {
            height: 2px;
            background-color: #4b5563; /* gray-600 */
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .division-step-row {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        .indent {
            margin-left: 2rem; /* Adjust as needed for alignment */
        }
        .relative-indent {
            position: relative;
        }
        .relative-indent .bit-container {
            position: absolute;
            left: 0;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-6 flex flex-col items-center min-h-screen">
    <div class="max-w-4xl w-full bg-white shadow-lg rounded-lg p-8">
        <h1 class="text-3xl font-bold text-center mb-6 text-indigo-700">Dyadische Polynomdivision</h1>
        <p class="text-center mb-8 text-gray-600">
            Diese Animation veranschaulicht die Bit-weise binäre Polynomdivision (Modulo-2-Arithmetik)
            für die Bitfolge <span class="font-mono bg-gray-200 px-1 py-0.5 rounded">1100110000</span>
            und das Generatorpolynom <span class="font-mono bg-gray-200 px-1 py-0.5 rounded">11001</span>.
        </p>

        <div class="flex flex-col items-center space-y-6">
            <div class="text-xl font-semibold text-indigo-600" id="step-display">Schritt 0</div>

            <div class="bg-gray-50 p-6 rounded-lg shadow-inner w-full">
                <div class="flex justify-between items-center mb-4">
                    <div class="text-lg font-medium text-gray-700">Dividend:</div>
                    <div id="dividend-display" class="bit-container text-xl"></div>
                </div>
                <div class="flex justify-between items-center mb-4">
                    <div class="text-lg font-medium text-gray-700">Divisor:</div>
                    <div id="divisor-display" class="bit-container text-xl"></div>
                </div>
                <div class="flex justify-between items-center mb-4">
                    <div class="text-lg font-medium text-gray-700">Quotient:</div>
                    <div id="quotient-display" class="bit-container text-xl"></div>
                </div>

                <hr class="my-4 border-t-2 border-gray-300">

                <div id="division-steps" class="flex flex-col items-start font-mono text-xl">
                    </div>

                <div class="flex justify-between items-center mt-6">
                    <div class="text-lg font-medium text-gray-700">Aktueller Rest:</div>
                    <div id="current-remainder-display" class="bit-container text-xl"></div>
                </div>
                <div class="flex justify-between items-center mt-4">
                    <div class="text-lg font-medium text-gray-700">Finaler Rest:</div>
                    <div id="final-remainder-display" class="bit-container text-xl"></div>
                </div>
            </div>

            <div class="flex space-x-4 mt-6">
                <button id="prev-btn" class="px-6 py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75 transition-all duration-200">
                    &larr; Zurück
                </button>
                <button id="play-pause-btn" class="px-6 py-3 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition-all duration-200">
                    Start
                </button>
                <button id="next-btn" class="px-6 py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75 transition-all duration-200">
                    Weiter &rarr;
                </button>
                <button id="reset-btn" class="px-6 py-3 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-75 transition-all duration-200">
                    Reset
                </button>
            </div>
        </div>
    </div>

    <script>
        const dividendStr = "1100110000";
        const divisorStr = "11001";
        const divisorLen = divisorStr.length;
        const remainderLen = divisorLen - 1; // Remainder length is one less than divisor length

        let steps = [];
        let currentStepIndex = 0;
        let isPlaying = false;
        let animationInterval;

        // DOM elements
        const stepDisplay = document.getElementById('step-display');
        const dividendDisplay = document.getElementById('dividend-display');
        const divisorDisplay = document.getElementById('divisor-display');
        const quotientDisplay = document.getElementById('quotient-display');
        const divisionStepsContainer = document.getElementById('division-steps');
        const currentRemainderDisplay = document.getElementById('current-remainder-display');
        const finalRemainderDisplay = document.getElementById('final-remainder-display');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const nextBtn = document.getElementById('next-btn');
        const prevBtn = document.getElementById('prev-btn');
        const resetBtn = document.getElementById('reset-btn');

        /**
         * Performs a bitwise XOR operation on two binary strings.
         * @param {string} a - The first binary string.
         * @param {string} b - The second binary string.
         * @returns {string} The result of the XOR operation.
         */
        function xor(a, b) {
            let result = '';
            for (let i = 0; i < a.length; i++) {
                result += (parseInt(a[i]) ^ parseInt(b[i])).toString();
            }
            return result;
        }

        /**
         * Creates a bit element with specified content and classes.
         * @param {string} bitValue - The bit character ('0' or '1').
         * @param {string[]} classes - Array of CSS classes to apply.
         * @returns {HTMLElement} The created div element.
         */
        function createBitElement(bitValue, classes = []) {
            const bitDiv = document.createElement('div');
            bitDiv.classList.add('bit', ...classes);
            bitDiv.textContent = bitValue;
            return bitDiv;
        }

        /**
         * Renders a bit string into a container.
         * @param {HTMLElement} container - The DOM element to render into.
         * @param {string} bitString - The binary string to render.
         * @param {number[]} activeIndices - Indices of bits to mark as 'active'.
         * @param {number[]} highlightIndices - Indices of bits to mark as 'highlight'.
         * @param {string} resultClass - Class for result bits (e.g., 'xor-result').
         * @param {number} startIndex - Starting index for rendering (for alignment).
         */
        function renderBits(container, bitString, activeIndices = [], highlightIndices = [], resultClass = '', startIndex = 0) {
            container.innerHTML = ''; // Clear previous content
            // Add empty bits for alignment if startIndex > 0
            for (let i = 0; i < startIndex; i++) {
                container.appendChild(createBitElement('', ['invisible'])); // Use invisible placeholder
            }
            for (let i = 0; i < bitString.length; i++) {
                const char = bitString[i];
                const classes = [];
                if (activeIndices.includes(i)) {
                    classes.push('active');
                }
                if (highlightIndices.includes(i)) {
                    classes.push('highlight');
                }
                if (resultClass) {
                    classes.push(resultClass);
                }
                container.appendChild(createBitElement(char, classes));
            }
        }

        /**
         * Pre-calculates all steps of the binary polynomial division.
         */
        function calculateSteps() {
            steps = [];
            let currentRemainder = dividendStr.substring(0, divisorLen);
            let quotient = '';
            let dividendProcessedIndex = divisorLen; // Index in original dividend

            // Initial state before any operations
            steps.push({
                quotient: '',
                currentRemainderBeforeXOR: '',
                xorOperand: '',
                xorResult: '',
                newRemainder: currentRemainder,
                dividendHighlightStart: 0,
                dividendHighlightEnd: divisorLen,
                quotientBitAdded: null,
                isFinalStep: false
            });

            // Loop through the rest of the dividend bits
            for (let i = 0; i < dividendStr.length - divisorLen + 1; i++) {
                const quotientBit = (currentRemainder[0] === '1') ? '1' : '0';
                quotient += quotientBit;

                const xorOperand = (quotientBit === '1') ? divisorStr : '0'.repeat(divisorLen);
                const xorResult = xor(currentRemainder, xorOperand);

                let nextDividendBit = '';
                if (dividendProcessedIndex < dividendStr.length) {
                    nextDividendBit = dividendStr[dividendProcessedIndex];
                }

                // The new remainder is the XOR result shifted left, with the next bit appended
                let newRemainder = xorResult.substring(1) + nextDividendBit;

                // Store step details
                steps.push({
                    quotient: quotient,
                    currentRemainderBeforeXOR: currentRemainder,
                    xorOperand: xorOperand,
                    xorResult: xorResult,
                    newRemainder: newRemainder,
                    dividendHighlightStart: i, // This is the start of the current window in the original dividend
                    dividendHighlightEnd: i + divisorLen, // End of current window
                    quotientBitAdded: quotientBit,
                    isFinalStep: (dividendProcessedIndex === dividendStr.length) // Check if this is the last bit to be pulled down
                });

                currentRemainder = newRemainder;
                dividendProcessedIndex++;
            }

            // After the loop, the `currentRemainder` holds the value before the *last* bit was pulled down
            // The actual final remainder is the last `xorResult` truncated to `remainderLen`
            const finalRemainder = steps[steps.length - 1].xorResult.substring(divisorLen - remainderLen);
            steps[steps.length - 1].finalRemainderValue = finalRemainder;
        }

        /**
         * Updates the display based on the current step index.
         */
        function updateDisplay() {
            const stepData = steps[currentStepIndex];
            stepDisplay.textContent = `Schritt ${currentStepIndex}`;

            // Render static elements
            renderBits(dividendDisplay, dividendStr);
            renderBits(divisorDisplay, divisorStr);
            renderBits(quotientDisplay, stepData.quotient);

            // Clear dynamic division steps
            divisionStepsContainer.innerHTML = '';

            // Render current remainder (before XOR) and XOR operation
            if (stepData.currentRemainderBeforeXOR) {
                const currentRemainderRow = document.createElement('div');
                currentRemainderRow.classList.add('division-step-row');
                // Calculate indentation for alignment
                const indentSize = (currentStepIndex - 1) * (1.8 + 0.25); // bit width + gap
                currentRemainderRow.style.marginLeft = `${indentSize}rem`;
                renderBits(currentRemainderRow, stepData.currentRemainderBeforeXOR, [], Array.from({ length: divisorLen }, (_, i) => i));
                divisionStepsContainer.appendChild(currentRemainderRow);

                const xorOperandRow = document.createElement('div');
                xorOperandRow.classList.add('division-step-row');
                xorOperandRow.style.marginLeft = `${indentSize}rem`;
                renderBits(xorOperandRow, stepData.xorOperand);
                divisionStepsContainer.appendChild(xorOperandRow);

                const lineDiv = document.createElement('div');
                lineDiv.classList.add('operation-line');
                lineDiv.style.marginLeft = `${indentSize}rem`;
                lineDiv.style.width = `${divisorLen * (1.8 + 0.25) - 0.25}rem`; // Adjust width based on bits
                divisionStepsContainer.appendChild(lineDiv);

                const xorResultRow = document.createElement('div');
                xorResultRow.classList.add('division-step-row');
                xorResultRow.style.marginLeft = `${indentSize}rem`;
                renderBits(xorResultRow, stepData.xorResult, [], [], 'xor-result');
                divisionStepsContainer.appendChild(xorResultRow);

                // Show the next bit being pulled down
                if (currentStepIndex < steps.length - 1) {
                    const nextBitIndexInDividend = (currentStepIndex - 1) + divisorLen; // Index of the bit that was pulled down
                    const nextBitValue = dividendStr[nextBitIndexInDividend];

                    const nextBitRow = document.createElement('div');
                    nextBitRow.classList.add('division-step-row');
                    nextBitRow.style.marginLeft = `${indentSize + (divisorLen * (1.8 + 0.25) - (1.8 + 0.25))}rem`; // Align to the right of the XOR result
                    renderBits(nextBitRow, nextBitValue, [], [], 'highlight');
                    divisionStepsContainer.appendChild(nextBitRow);
                }
            }

            // Update current remainder display
            if (stepData.newRemainder) {
                renderBits(currentRemainderDisplay, stepData.newRemainder);
            } else {
                currentRemainderDisplay.innerHTML = '';
            }

            // Update final remainder display (only at the very last step)
            if (stepData.isFinalStep && stepData.finalRemainderValue) {
                renderBits(finalRemainderDisplay, stepData.finalRemainderValue, [], [], 'result');
            } else {
                finalRemainderDisplay.innerHTML = '';
            }

            // Highlight active part of dividend in the main display
            const dividendBits = dividendDisplay.children;
            for (let i = 0; i < dividendBits.length; i++) {
                dividendBits[i].classList.remove('active', 'highlight');
                if (i >= stepData.dividendHighlightStart && i < stepData.dividendHighlightEnd) {
                    dividendBits[i].classList.add('active');
                }
                // Highlight the specific bit being pulled down
                if (currentStepIndex > 0 && i === (currentStepIndex -1) + divisorLen) {
                    dividendBits[i].classList.add('highlight');
                }
            }

            // Update button states
            prevBtn.disabled = currentStepIndex === 0;
            nextBtn.disabled = currentStepIndex === steps.length - 1;
            if (currentStepIndex === steps.length - 1) {
                playPauseBtn.textContent = 'Start';
                isPlaying = false;
                clearInterval(animationInterval);
            }
        }

        /**
         * Advances to the next step.
         */
        function nextStep() {
            if (currentStepIndex < steps.length - 1) {
                currentStepIndex++;
                updateDisplay();
            }
        }

        /**
         * Goes back to the previous step.
         */
        function prevStep() {
            if (currentStepIndex > 0) {
                currentStepIndex--;
                updateDisplay();
            }
        }

        /**
         * Toggles play/pause for the animation.
         */
        function togglePlayPause() {
            isPlaying = !isPlaying;
            if (isPlaying) {
                playPauseBtn.textContent = 'Pause';
                animationInterval = setInterval(() => {
                    if (currentStepIndex < steps.length - 1) {
                        nextStep();
                    } else {
                        togglePlayPause(); // Stop at the end
                    }
                }, 1500); // 1.5 seconds per step
            } else {
                playPauseBtn.textContent = 'Start';
                clearInterval(animationInterval);
            }
        }

        /**
         * Resets the animation to the beginning.
         */
        function resetAnimation() {
            clearInterval(animationInterval);
            isPlaying = false;
            playPauseBtn.textContent = 'Start';
            currentStepIndex = 0;
            updateDisplay();
        }

        // Event Listeners
        playPauseBtn.addEventListener('click', togglePlayPause);
        nextBtn.addEventListener('click', nextStep);
        prevBtn.addEventListener('click', prevStep);
        resetBtn.addEventListener('click', resetAnimation);

        // Initialize on window load
        window.onload = function() {
            calculateSteps();
            updateDisplay();
        };
    </script>
</body>
</html>
